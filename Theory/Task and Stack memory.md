## 메모리 단편화
>메모리 공간이 작은 조각으로 나뉘어 있어, 전체 가용 공간은 충분함에도 불구하고 필요한 크기의 메모리를 할당하지 못하는 상태이다.

### 메모리 단편화의 종류
#### 1. 외부 단편화
- **정의:** 메모리 할당과 해제가 반복되면서, 중간중간 사용하지 않는 작은 빈 공간들이 생기는 현상이다.
- **문제점:** 빈 공간들의 합계는 요청한 크기보다 크지만, 공간들이 연속적이지(Contiguous) 않아서 할당이 불가능해진다.
- **예시:** 10KB가 비어있는데, 5KB, 2KB, 3KB로 쪼개져 있다면 7KB 할당 요청을 처리할 수 없다.
#### 2. 내부 단편화 (Internal Fragmentation)
- **정의:** 메모리 할당 시 하드웨어나 관리 시스템의 효율을 위해 고정된 크기(예: 4KB Page)로 할당할 때, 실제 요청한 크기보다 더 큰 메모리가 할당되어 내부 공간이 낭비되는 현상이다.
- **문제점:** 할당된 블록 내부에 남는 공간은 다른 프로세스가 사용할 수 없어 메모리 낭비가 발생한다.
- **예시:** 4KB 단위로 메모리를 할당하는 시스템에서 1KB만 요청해도 4KB가 할당되므로, 내부적으로 3KB의 낭비가 생긴다.
### 해결책
### 1. 가급적 처음부터 크게 할당하는 방법 (Memory Pooling)
>**'Memory Pool'** 또는 **'Static Allocation'** 기법이라고 부른다.

- **핵심 개념**: 필요한 최대 메모리 크기를 미리 예측하여, 프로그램 시작 시점에 거대한 배열 형태로 미리 잡아두는 방식이다.
    
- **장점**:
    - **외부 단편화 제로**: 메모리를 줬다 뺏다(Alloc/Free) 하지 않고 큰 덩어리를 고정해서 쓰기 때문에 조각이 날 일이 없다.
        
    - **결정성(Determinism) 보장**: 할당에 걸리는 시간이 일정하여 실시간 시스템에 유리하다.
        
- **단점**:
    - **내부 단편화 발생**: 실제로 10KB만 써도 미리 100KB를 잡아뒀다면 나머지 90KB는 낭비된다.
        
- **FreeRTOS**: `xTaskCreateStatic()` 함수를 사용하면 스택 공간을 힙이 아닌 정적 배열로 할당할 수 있다.

### 2. 부팅하자마자 미리 Task를 생성/할당하는 방법 (Pre-allocation)
>**'Initialization Phase Allocation'** 전략이라고 부른다.

- **핵심 개념**: 런타임에는 Task를 생성하거나 삭제하지 않고, `main()` 함수에서 스케줄러가 돌기 전에 필요한 모든 자원을 다 만들어두는 방식이다.
    
- **장점**:
    - **안정성**: 만약 메모리가 부족하다면 부팅 직후에 바로 알 수 있어, 운영 중에 갑자기 메모리 부족으로 시스템이 뻗는 '런타임 에러'를 방지할 수 있다.
        
    - **파편화 억제**: task를 동적으로 생성/삭제할 때 발생하는 '메모리 구멍' 현상을 원천 차단한다.
        
- **단점**:
    - 초기 부팅 시간이 약간 길어질 수 있고, 사용하지 않는 Task도 메모리를 계속 점유하게 된다.
        
- **실제 사례**: 항공, 자동차 등 미션 크리티컬한 시스템에서는 운영 중 `vTaskDelete()`나 `malloc()` 사용을 아예 금지하기도 한다.
