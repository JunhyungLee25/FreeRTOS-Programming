### 2026-01-04
STM32F7 package가 설치가 안되어있어서 코드 생성이 안됐었다.
<br> STM 가입하고 package 설치하였다.
<br>`.ioc` 파일은 설계도 일뿐, `.ioc` 이용해서 코드를 생성해야 한다.

### 2026-01-10
![](../images/Pasted_image_20260110151109.png)
<br>toggle breakpoint : 디버깅 모드에서 사용할 break point 설정


![](../images/Pasted_image_20260110152518.png)
<br>코드는 항상 begin과 end 사이에 추가

scalability mode: 이 모드가 활성화되면 다음 기능들이 제한될 수 있다.

- **코드 폴딩(Code Folding):** `+`, `-` 버튼을 눌러 함수 내용을 접었다 펴는 기능이 작동하지 않을 수 있다.
    
- **실시간 문법 에러 표시:** 코드를 치자마자 빨간 줄이 뜨는 기능이 꺼질 수 있다.
    
- **하이퍼링크 (Ctrl + Click):** 함수 이름을 눌러서 정의된 곳으로 이동하는 기능이 느려지거나 안 될 수 있다. 

### 2026-01-11
![](../images/Pasted_image_20260111204308.png)
- Window/ShowView/Build analyze를 통해 메모리 사용량 확인 가능

### 2026-01-14
## CMSIS
>서로 다른 제조사가 만든 ARM Cortex 기반 칩들을 똑같은 방식으로 제어할 수 있게 만든 표준화된 통역 도구.

- 코어텍스 마이크로 컨트롤러 소프트웨어 인터페이스 표준(CMSIS)으로 ARM CORTEX 프로세서 기반 마이크로 컨트롤러 벤터 독립 하드웨어 추상화 계층이다.
- CMSIS는 일반 도구 인터페이스를 정의하고 일관된 장치 지원을 가능하게 한다.
- CMSIS 소프트웨어 인터페이스는 소프트웨어 재사용을 단순화하고 마이크로 컨트롤러 개발자의 학습 곡선을 줄이며 새로운 장치의 출시 시간을 단축한다.
- CMSIS는 프로세서 및 주변 장치, 실시간 운영체제 및 미들웨어 구성 요소에 대한 인터페이스를 제공한다. CMSIS에는 장치, 보드 및 소프트웨어에 대한 전달 메커니즘이 포함되어 있으며 여러 공급 업체의 소프트웨어 구성 요소를 결합할 수 있다.
### CMSIS의 핵심 구성 요소

- CMSIS는 단순히 하나로 되어 있지 않고, 역할에 따라 여러 층으로 나뉜다.

1. **CMSIS-CORE**: 가장 기본이 되는 부분으로 Cortex-M 프로세서의 코어 레지스터와 인터럽트 컨트롤러(NVIC) 등에 접근하는 인터페이스를 제공한다.
2. **CMSIS-RTOS**: 운영체제(RTOS)를 위한 표준 API이다. 사용자가 FreeRTOS를 쓰든, 다른 OS를 쓰든 동일한 함수 호출로 태스크를 만들 수 있게 해준다.
3. **CMSIS-DSP**: 디지털 신호 처리(복소수 계산, 필터 등)를 위한 고성능 라이브러리이다. ARM 코어의 성능을 최대한 활용하도록 최적화되어 있다.
4. **CMSIS-Driver**: 미들웨어(USB, TCP/IP, Flash 등)와 주변 장치를 연결하는 범용 드라이버 인터페이스이다.
## HAL
>SPL(Standard Peripheral Library)의 중단에 대한 대안으로 등장

- HAL 드라이버는 풍부한 API 세트를 제공하고 애플리케이션 상위 계층과 쉽게 상호 작용하도록 설계되었다.
- 각 드라이버는 가장 일반적인 주변 장치 기능을 포함하는 기능 세트로 구성된다. 각 드라이버의 개발은 드라이버 구조, 기능 및 매개 변수 이름을 표준화하는 공통 API에 의해 주도된다.
- HAL의 가장 큰 장점은 이식성이다.
- 클럭 설정, 핀 muxing, 주변 장치 설정 등을 위한 코드의 생성을 위한 STM32CubeMX 도구와 결합하여 장치 전체에 표준화된 API를 제공함과 동시에 자연스럽게 연동 된다.

### 2026-01-17

FreeRTOSConfig_base.h와 FreeRTOSConfig.h 사이 관계.
<br>base 파일은 모든 소스파일에 동일하고 그냥 config 파일은 base 파일을 기반으로 변경된 것만을 적어놓았기 때문에. 각 실습 별로 차이점을 알기 쉽다.

### 2026-01-18
![](../images/Pasted_image_20260118133613.png)
- build하여 각 파일의 size를 알 수 있다.
![](../images/Pasted image 20260118133711.png)
- 컴파일 이후 만들어지는 list 파일을 통해 프로그램의 MAP 정보를 알 수 있다.

![](../images/Pasted_image_20260118134027.png)
- user heap loaction: 0x20004808

디버깅 모드로 확인
<br>![](../images/Pasted_image_20260118135051.png)
- main stack이 어디서 부터 시작되는지 알 수 있다. 
실행버튼 누른 후
<br>![](../images/Pasted_image_20260118140109.png)
<br>![](../images/Pasted_image_20260118140701.png)
- task 스택에 대해 알 수 있다
1. MAP 파일을 통해 알 수 있는 정보
	`.bss` 영역 시작: 0x2000006c
	`.bss` 영역 크기: 0x0000479c
	`.bss` 영역 끝: 0x20004808
2. 현재 task의 sp 값은 `0x20000e88`로 범위 내에 존재한다.
	FreeRTOS에서 `vTaskCreate()`를 호출하면, 커널은 내부적으로 `pvPortMalloc()`을 사용하여 `bss`에 TCB와 Stack 공간을 할당한다.
- bss내에 task가 생성됨을 알 수 있다.

#### MSP vs PSP
- **MSP (Main Stack Pointer):** $0x2007ffe0$
    - **역할:** 커널(OS)의 핵심 로직, 리셋 직후의 초기화 코드, 그리고 모든 **인터럽트(ISR)** 상황에서 사용된다.
    - **위치:** 링커 스크립트에 정의된 전체 RAM의 끝 지점(SRAM2 영역)에서 아래로 자라난다. 그래서 주소값이 높게 형성된다.
        
- **PSP (Process Stack Pointer):** $0x20000e88$
    - **역할:** 실제 실행 중인 **개별 Task**가 자신의 로컬 변수를 저장하거나 함수를 호출할 때 사용한다.
    - **위치:** FreeRTOS 힙 영역(보통 `.bss` 섹션 내의 `ucHeap` 배열)에서 할당받는다. 앞서 MAP 파일에서 확인한 $0x2000....$ 영역에 위치하는 이유이다.

#### 인터럽트 상황에서 sp -> msp로 전환되는 이유
>태스크 스택(PSP)의 불안정성으로부터 시스템 전체를 보호하고, 인터럽트가 중첩되어도 커널이 안전하게 동작할 수 있는 공간을 확보하기 위해서이다.

1. 태스크 스택의 불안정성 (Stack Overflow 방지)
	개별 태스크는 한정된 자원(Heap 영역의 일부)을 쪼개서 사용한다.

- **위험 상황:** 만약 특정 태스크에서 지역 변수를 너무 많이 잡거나 재귀 함수를 써서 자신의 스택($0x20000e88$ 부근)을 거의 다 써버렸을 때 인터럽트가 발생고 인터럽트가 여전히 그 태스크의 스택(PSP)을 사용한다면, 인터럽트 핸들러가 실행되면서 태스크의 메모리 영역을 침범하고 시스템이 즉시 다운 될 것이다.
    
- **해결:** 하드웨어(Cortex-M)가 인터럽트 시점에 자동으로 안전한 MSP($0x2007ffe0$)로 갈아타게 함으로써, task가 아무리 엉망이 되어도 시스템 관리(인터럽트)는 안정적으로 수행될 수 있게 보호하는 것이다.
    
2. 인터럽트 중첩(Nested Interrupt) 처리
	임베디드 시스템에서는 우선순위가 높은 인터럽트가 실행 중인 인터럽트를 끊고 들어올 수 있다.

- 인터럽트가 중첩될 때마다 스택이 계속 쌓이게 되는데, 이를 모든 개별 태스크 스택에 대비해서 넉넉히 잡아주는 것은 메모리 낭비이다. 대신, 모든 인터럽트가 하나의 공용 통로인 MSP를 사용하게 하면, MSP 영역만 충분히 확보해두면 어떤 task가 실행 중이든 상관없이 인터럽트 처리가 가능해진다.
    
3. 하드웨어의 자동 동작 (Exception Entry)

	이 과정은 소프트웨어가 아니라 **CPU 하드웨어**가 수행한다.

- 인터럽트 발생 시, 하드웨어가 현재 사용 중인 레지스터들($R0 \sim R3$, $R12$, $LR$, $PC$, $xPSR$)을 현재 스택(PSP)에 자동으로 저장(Push)한다.  그 직후, CPU 내부의 `CONTROL` 레지스터가 변하면서 스택 포인터가 **MSP**로 자동 전환된다. 인터럽트 핸들러(`ISR`)는 이제 $0x2007ffe0$부터 시작하는 널널한 MSP 공간을 사용한다.
    
