# 태스크

실제로 물리적인 CPU는 하나이다.
태스크는 가상의 CPU를 각자 가지고 있는 것 처럼 동작한다.
![](images/Pasted_image_20260110190128.png)
시간을 분할하여 사용할 수 있도록 해준다.
물리적으로 하나의 CPU는 한 번에 하나의 명령어만 처리할 수 있기 때문에, 시분할 기법을 사용하여 여러 태스크를 아주 짧은 시간 간격으로 실행하여 동시에 돌아가는것처럼 보이게 한다.

## 태스크간의 통신(IPC)

태스크 A와 태스크 B는 커널 서비스인 Inter-process communication을 이용해 통신한다.
![](images/Pasted_image_20260110190737.png)

## 태스크 상태

멀티 태스킹 환경에서 커널은 실행 중에 상태를 계속 변경한다.
![](images/Pasted_image_20260110190804.png)

running: execute
blocked: not execute. sleep=waiting.  
ready: not execute. 아직 자신의 차례가 오지 않음.

# 커널
>**커널**(kernel)은 컴퓨터 운영 체제의 핵심이 되는 컴퓨터 프로그램으로, 시스템의 모든 것을 완전히 제어(control)한다. 운영 체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러 가지 서비스를 제공한다

![](images/Pasted_image_20260110191050.png)


## 선점형 커널
>선점형 커널은 어떤 한 task가 수행하고 있는 도중에도 kernel이 그 task의 수행을 중지 시키고 다른 task(중지되는 task 보다 priority가 높은)를 수행시킬 수 있는 능력을 소유한다.

- 가장 높은 우선순위의 task가 CPU를 점유하여 수행될 수 있음
- 시스템 응답성이 중요한 경우 사용됨
- 실시간 운영체제에서 사용하는 구조임
![](images/Pasted_image_20260110191440.png)
	인터럽트가 High-priority Task를 깨우면 그 즉시 동작함
## 비선점형 커널

![](images/Pasted_image_20260110191631.png)
	인터럽트는 High-priority Task를 깨워도 즉시 동작하지 않음.
- **타임 퀀텀(Time Quantum)** 은 프로세스가 CPU를 사용할 수 있도록 부여받은 '최대 시간'을 의미하지만, 비선점형의 특성상 이 시간이 지났다고 해서 OS가 강제로 CPU를 뺏어올 수 없다. -> 타임 퀀텀이 종료되더라도, 현재 실행 중인 프로세스가 스스로 CPU를 반납(Yield)하거나 I/O 작업을 위해 대기 상태로 들어가지 않는 한, 커널은 CPU를 **강제로 뺏을 수 없다.**

## Round-Robin 스케쥴링
>모든 태스크들이 시간 자원(CPU)을 공평히 나누어 사용하는 개념.

- 각 태스크들이 점유하는 시간을 타임퀀텀이라고 한다.
	타임퀀텀의 크기는 특별히 정해지지 않으나 대략 1ms~20ms를 많이 사용한다. -> 타임퀀텀이 너무 짧으면 문맥 전환을 위한 시간 자원의 낭비가 심하다.
	하지만 어플리케이션이 단순한 비선점형 스케쥴링만을 필요로 할 경우 최적임
	![](images/Pasted_image_20260110192251.png)
	

## Priority 스케쥴링
>태스크를 중요도에 의해 가중치를 두어 우선적으로 실행할 수 있도록 하겠다는 개념.

- 실시간 운영체제(RTOS)에서 필수적으로 지원하는 스케쥴링 방법이다.
- 선점형 스케쥴링의 특성을 부여받음.
	![](images/Pasted_image_20260110192447.png)
	우선순위가 높은 task가 생기면 무조건 cpu 점유함(선점형 커널 시)

## 인터럽트
>비동기적 이벤트의 발생을 처리하기 위한 메커니즘

- 인터럽트 발생 시 문맥을 저장하고 ISR로 점프
- 활성, 비활성화 가능 -> 비활성화 시간은 가능한 짧게 해야한다.
- 지연시간: 외부 하드웨어에서 인터럽트 신호가 발생한 시점부터, CPU가 해당 인터럽트를 처리하는 루틴(ISR)의 첫 번째 명령어를 실행하기까지 걸리는 시간을 의미한다.  -> 비활성화 최대시간 + ISR 최초 명령시간
	![](images/Pasted_image_20260110193123.png)

- 인터럽트 비활성화 하는법
	1. CPU가 마스킹을 통해 인터럽트 요청 보류(pending)됨. 마스킹 해제되면 시작됨
	2. Interrupt controller에 들어오는 개별적인 인터럽트 요청을 마스킹한다. -> CPU와 달리 하드웨어 주변장치를 개별적인 처리가 가능한것이 차이점.

## Blocking I/O
>Blocking I/O 동작은 태스크가 시스템콜을 호출했으나 점유하고자 하는 데이터가 즉시 가용하지 않을 경우 그 동작이 완료될 떄 까지 suspending(blocked) 상태로 유지되는 것을 말함

![](images/Pasted_image_20260110193904.png)

## Non-Blocking I/O
>Non-Blocing I/O 동작은 태스크가 시스템콜을 호출 했으나 점유하고자 하는 데이터가 즉시 가용하지 않을 경우 즉각 리턴하는 것

![](images/Pasted_image_20260110200217.png)

### Blocking vs Non-Blocking
Blocking 장점: cpu를 사용하지 않는 휴면상태에 들어가 입력을 기다릴 수 있다.
Blocking 단점: 함수실행 후 휴면상태에 들어가면 아무 코드도 실행할 수 없다.

Non-Blocking 장점: 휴면상태에 들어가지 않고 loop 계속 실행 가능
Non-Blocking 단점: 휴면상태로 들어가 기다리지 않고 계속 함수 실행하여 확인해야한다.

## 커널의 시계(TICK)
>정기적(Periodic)으로 일어나는 인터럽트

- 태스크 지연(delayed), 타임아웃(timeout)을 제공한다.
- 태스크 지연의 분해능(clock resolution)은 클럭 틱(TICK) 하나
- 클럭 틱 단위 정확도로 지연가능한 것은 아니다
	선점형 커널에서는 가능함

![](images/Pasted_image_20260110200921.png)
- 리눅스 커널 내부에서는 '1초에 틱이 몇 번 발생하는가'를 **HZ**라는 상수로 정의한다.
	**HZ:** 시스템 설정에 따라 100, 250, 1000 등으로 설정된다. (예: HZ=1000이면 1ms마다 틱 발생)

## RTOS란
>여러 태스크를 동시에 처리하는 멀티태스킹 능력과, 어떤 상황에서도 특정 작업이 정해진 시간(Deadline) 안에 완료됨을 보장하는 실시간성을 제공하는 OS이다.

실시간 컴퓨팅 시스템이란 사용할 수 있는 자원이 한정되어 있는 상황에서 작업 수행이 요청되었을 때, 이를 제한된 시간안에 처리해 결과를 내주는 것을 말한다. 이때, '제한된 시간'은 굉장히 모호한 단어이다. 어떤 시스템은 1초 이내만 동작해도 성공. 어떤 시스템은 0.001초 이내에 동작해야만 성공이라고 부를 수 있기 때문이다.

예를 들어, 커피머신에서 커피가 조금 늦게 나온다고 해서 사람들은 크게 의식하지 않을 것이다. 하지만, 자동차의 브레이크가 평소보다 느리게 반응한다면 사람들은 굉장히 심각하게 반응할 것이다. 이처럼 상황을 고려하여 소프트 리얼타임과 하드 리얼타임으로 나눌 수 있다.
- 소프트 리얼타임: 기준 시간이 있지만, 시간 안에 시스템이 응답을 못하더라도 실패가 용인되는 시스템(ex: 커피머신, 스마트폰)
- 하드 리얼타임: 약속한 완료 시간을 반드시 지켜야 되는 시스템(ex: 미사일, 로켓)

### RTOS의 특징

- Hard Realtime
- Scalability
- Preemptive
- Multitasking
- Deterministic(예측가능)
- Porability
- Robustness

### freeRTOS의 특징

- Poratable: 35개 이상의 마이크로컨트롤러에 이식. 커널 코드의 대부분이 이식 가능한 ANSI C를 기반(일부 마이크로프로세서에 국한된 부분은 어셈블러로 코딩)
- ROMable: 해당 C 컴파일러, 어셈블러, 링커, 로더가 필요, 설정이나 응용프로그램에 따라 메모리의 크기를 자유로이 결정할 수 있다.
- 커널 바이너리 이미지는 4K에서 9K 바이트 영역
- Preemptive Scheduling: 높은 우선 순위 작업이 먼저 수행된다.
- Round Robin Support
- Real-Time: 빠른 응답성을 갖는다.
- Multitasking: 독자적 우선순위를 가지는 무제한으로 생성 가능한 태스크
- 임베디드 운영체제로써 대표적인 공개형 소스코드 기반 커널
- 신뢰성과 안정성을 가진다.
	작은 사이즈-> 많은 시스템에 적용가능
	작은 임베디드 시스템에 탑재 가능하며 임베디드 시스템 중에서도 강력한 네트워크가 필요한 곳과 높은 성능 시스템에 사용하는 것이 적합
- 프로젝트에 따른 소스 코드의 절약이 가능
- 스택오버플로우체크, 처리시간 체크, 후크(HOOK), Queue, Semaphore 5가지 Heap memory등의 시스템 서비스 제공
- 저전력 어플리케이션을 위한 틱리스(tickless) 모드 지원
- 효율적인 소프트웨어 타이머 지원
- 인터럽트 관리
	태스크의 수행을 일시 중지하거나 재개가 가능하다.
	인터럽트 중첩가능
- 강력한 실행 추적 기능
- 스택 오버플로우 감지 옵션

- 단점
	디바이스 드라이버 부재
	멀티코어 지원 안됨

