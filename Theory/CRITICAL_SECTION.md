# Critical Section
>공유 자원을 사용 중인 함수내의 일부 혹은 전체 영역
- 일단 이 코드 영역의 실행이 시작되면 적어도 다른 태스크(설령 우선순위가 높은 태스크라 할지라도)가 이 영역을 선점하여 실행하는 일이 없어야 하고 그렇게 하도록 한다.
- 임계영역을 보호하기 위한 장치는 다음과 같은 것이 있다.
	<br>인터럽트 중단
	<br>스케줄링 중단
	<br>[세마포어](./Semaphore.md)(상호배제 커널 서비스)
## 동시성 문제
<br>![](../images/Pasted_image_20260126191410.png)

- 비원자적 연산 예시
<br>![](../images/Pasted_image_20260126202006.png)
<br>[03_CRITICAL](../Labs/03_CRITICAL.md) 실습 과정에서 확인한 어셈블리 동작을 통해 볼 수 있듯이 5단계에 걸쳐 메모리->레지스터->메모리로 연산이 진행된다. 
<br>이때 문맥전환은 어셈블리 한 줄마다 발생하는데 TASK1과 TASK2는 각자의 r3를 이용하여 연산하지만, TASK1이 메모리에 값을 완전히 업데이트 하기전에 TASK2가 연산을 진행하면 잘못된 값이 메모리에 올라간 상태로 계속해서 연산을 진행하게 되어 결과적으로 의도하지 않은 값을 얻게 된다.

## 재진입(Reentrancy)
- 멀티태스킹 환경 그리고 다수의 태스크에서 호출하여 사용할 수 있도록, 해당 함수는 재진입 가능하도록 작성되어 있어야 한다.
- 멀티태스킹 환경이긴 하지만 단일 태스크만이 독점하여 사용할 것으로 확신 할 수 있는 경우에는 해당 함수는 재진입이 아니어도 무방하다.

- 멀티태스킹 환경에서 함수의 재진입이 불가한 경우
```c
int Temp; /*전역변수*/ 
void swap(int *x, int *y) 
{ 
    Temp    = *x; 
    *x     = *y; 
    *y     = Temp; 
}
```
<br> Temp를 공유하고 있으므로 재진입 불가

- 함수를 재진입 가능하도록 하려면
	- 전역변수를 사용하지 않는다.
	- 세마포어 같은 커널 리소스로 전역변수를 보호한다.
	- 전역변수 사용하는 동안 인터럽트 작동을 임시로 중단한다.
```c
void swap(int *x, int *y) 
{
	int Temp; // 지역변수 사용
    Temp    = *x; 
    *x     = *y; 
    *y     = Temp; 
}
```

## 상호배제(Mutual Exclusion) 방법들
### 1. 인터럽트 금지
- 선점이 작동하기 위해서는 인터럽트 발생이 필수적이다.
- 공유자원을 사용하는 동안 인터럽트를 비활성화하면 문맥 전환, 선점 무엇도 동작하지 않는다. 즉, 멀티 태스킹이 동작하지 않게 된다.
- 임계영역코드의 실행 시간이 비교적 아주 짧은 경우에 효과적이다.
- 타임 TICK 인터럽트의 주기를 놓치지 않도록 주의해서 사용해야 한다.
- 사용 예
```c
task1( ) 
{ 
    . . . 
	인터럽트 비 활성화 (disable) 
	공유 자원 액세스 (임계영역) 
	인터럽트 활성화 (enable) 
    . . . 
}
```
### 2. 스케줄링 중단
- 공유자원을 사용하는 동안 스케줄링을 금지시킨다.
- **FreeRTOS에서는 지원하지 않는다.**
- 임계영역코드의 실행 시간이 비교적 아주 짧은 경우 효과적이다.
- 이 실행이 빈번할 경우 높은 우선 순위 태스크 실행이 늦어지는 현상이 발생할 가능성이 있다.
- 사용 예
```c
task1( ) 
{ 
    . . . 
	스케줄링 중단(disable) 
	공유 자원 액세스 (임계영역) 
	스케줄링 재개 (enable) 
    . . . 
}
```
#### 3. 세마포어류(세마포어, 뮤텍스)의 커널서비스 사용
- 상호 배제로 즐겨 사용되는 방법으로 가장 추천되고 안전한 방법이다
- 사용이 지나치게 많을 경우 태스크의 blocking이 잦아지며 이로 인한 오버헤드 증가
- 사용 예
```c
task1( ) 
{ 
    . . . 
	세마포어 LOCK 
	공유 자원 액세스 (임계영역) 
	세마포어 UN-LOCK 
    . . . 
}
```
### 4. 하나의 task가 독점하는 방법
- 가장 이상적인 방법이다.
- 공유 자원을 퇴도록 사용하지 않는다.
- 공유 자원(변수, I/O 장치)을 사용하더라도 이 자원을 다수의 태스크가 공유 하도록 하지 않는다.
- 사용 예
```c
task1( ) 
{ 
    . . . 
	//세마포어 LOCK 
	공유 자원 액세스 (task1이 독점) 
	//세마포어 UN-LOCK 
    . . . 
}
```

### Critical Section
- [taskENTER_CRITICAL()](../FreeRTOS_reference_Manual/taskENTER_CRITICAL().md),[taskEXIT_CRITICAL()](../FreeRTOS_reference_Manual/taskEXIT_CRITICAL().md): FreeRTOS에서의 critical section 보호
- 인터럽트 비활성화 시간은 실시간 운영체제의 중요한 성능지표이다.
	리얼 타임 이벤트의 응답 시간을 결정한다
- 응용 프로그램에서도 사용할 수 있다.
	단, 인터럽트 비활성화 상태에서 사용하면 시스템이 멈출수도 있다.
	임계구역 내에서 커널 함수 사용하지 않는 것이 좋다.
	ex) `vTaskDelay()`
- **FreeRTOS 서비스를 호출할 때 인터럽트는 꼭 활성화 상태여야 한다.** 
- 사용 예
```c
{ 
    taskENTER_CRITICAL(); // 인터럽트 비활성화
    /* Critical Section*/ 
    taskEXIT_CRITICAL(); // 인터럽트 활성화
}
```
- FreeRTOS의 절대 우선 순위
<br>![](../images/Pasted_image_20260126210734.png)
<br>`taskENTER_CRITICAL()`에서의 우선순위는 어디까지 인터럽트를 비활성화 할 것인가를 결정하는 경계선이다.

우선순위는 태스크 우선순위(숫자 클수록 우선순위 높음)와 인터럽트 우선순위(숫자 작을수록 우선순위 높음)가 존재한다.
