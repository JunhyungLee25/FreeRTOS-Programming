### 1. 전역 변수 선언량, 이를 사용하는 태스크수와 그 참조 횟수를 줄인다.
#### 1.1 메모리 고정 점유 (Memory Footprint)

전역 변수는 프로그램이 실행되는 동안 메모리의 **데이터 영역(.data)** 이나 **BSS 영역(.bss)** 에 계속 상주한다.

- **지역 변수:** 함수가 실행될 때만 스택(Stack)에 잠시 머물렀다 사라지므로 메모리를 효율적으로 나눠 쓸 수 있다.
    
- **전역 변수:** 사용하지 않는 순간에도 메모리를 딱 차지하고 있기 때문에, 메모리 자원이 한정된 임베디드 시스템에서는 다른 프로세스나 태스크가 사용할 공간을 뺏는 결과를 초래한다.
    
#### 1.2 캐시 적중률 감소 (Cache Locality)

- 스택에 있는 지역 변수들은 메모리상에서 서로 모여 있어 캐시 적중률(Cache Hit Rate)이 높다.
    
- 반면 전역 변수는 메모리의 여러 곳에 흩어져 있을 가능성이 커서 CPU가 데이터를 가져올 때 캐시 미스가 자주 발생하며, 이는 곧 실행 속도 저하로 이어진다.
    
#### 1.3 명령어 처리 오버헤드 (Instruction Overhead)

임베디드 환경(특히 ARM 아키텍처)에서는 전역 변수에 접근할 때 추가적인 과정이 필요하다.

- **지역 변수:** 스택 포인터(SP)를 기준으로 상대적인 위치를 계산해 곧바로 접근할 수 있다.
    
- **전역 변수:** 변수의 절대 주소를 알아야 하므로, 주소 값을 먼저 레지스터로 로드한 뒤 다시 그 주소에 있는 값을 읽어오는 **간접 참조** 방식이 사용된다. 이 과정에서 명령어개수가 늘어나고 실행 시간이 길어진다.
    
#### 1.4 동기화 및 레이스 컨디션 (Race Condition)

이 부분이 가장 치명적인 오버헤드다.

- 전역 변수는 여러 태스크나 인터럽트 서비스 루틴(ISR)에서 동시에 접근할 수 있는 **공유 자원**이다.
    
- 데이터가 깨지는 것을 막기 위해 **뮤텍스(Mutex), 세마포어(Semaphore), 혹은 Spinlock** 같은 동기화 기법을 써야 한다.
    
- 이런 잠금(Lock) 메커니즘을 사용하는 것 자체가 CPU 연산 자원을 소모하며, 락을 기다리는 과정에서 **Context Switching**이 빈번해져 시스템 전체에 큰 부하를 준다.
****
### 2. 시간 소요가 많은 인터럽트 루틴은 가급적 IPC(xSemaphoreGive)를 활용하여 태스크에서 그 일을 수행하도록 구현한다. 
- ISR이 실행되는 동안 다른 태스크나 낮은 우선순위 인터럽트가 멈추기 때문이다.

### 3. **간단한 코드**의 임계영역 보호시에는 세마포어보다는 가급적 `taskENTER_CRITICAL`을 활용한다.
- 세마포어는 내부적으로 스케줄러를 건드리고 태스크의 상태를 변경하는 등 오버헤드가 크다. 반면에, `taskENTER_CRITICAL`은 단순히 CPU의 인터럽트를 잠시 끄는 방식이라 매우 빠르다. 코드가 짧고 금방 끝나는 작업이라면 인터럽트를 잠깐 끄는게 훨씬 효율적이다.
  
### 4. 빈번히 호출되는 함수를 인라인 어셈블리 등을 이용하여 최적화한다.

### 5. 기능 구현이후 프로세서의 클럭 속도를 가감하여 최적의 스피드를 결정한다. 
- IDLE 태스크의 CPU 점유율 판단한다. IDLE 태스크의 점유율이 높을수록 CPU가 하는 일이 없다는 뜻이다. 이때는, 클럭 속도를 낮춰서 소비 전력을 줄이거나, 반대로 점유율이 너무 낮다면 클럭을 높여 시스템 안정성을 확보해야한다.

### 6. TICK 시간이 절대적으로 지켜지는지 감시한다. 
- 오실로(로직) 스코프 활용한다. 타이머 인터럽트가 정확히 실행되는지 확인해야한다.